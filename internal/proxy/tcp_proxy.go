package proxy

import (
	"bytes"
	"context"
	"crypto/sha1"
	"encoding/base64"
	"errors"
	"fmt"
	"net"
	"net/http"
	"net/url"
	"time"

	"github.com/basemachina/bridge/internal/rand"
	"github.com/go-logr/logr"
)

// tcp means disable tls, tcp://
const TCPScheme = "tcp"

// DialContextFunc is a type alias of the net.DialContext
type DialContextFunc = func(ctx context.Context, network string, address string) (net.Conn, error)

var (
	ErrBadGateway = errors.New(http.StatusText(http.StatusBadGateway))
	ErrBadRequest = errors.New(http.StatusText(http.StatusBadRequest))
)

// TCPProxy represents tcp proxy.
type TCPProxy struct {
	logger          logr.Logger
	dialContextFunc DialContextFunc
}

// NewTCPProxy creates a new tcp proxy.
func NewTCPProxy(logger logr.Logger) *TCPProxy {
	return &TCPProxy{
		logger: logger,
		// the same as DefaultTransport
		dialContextFunc: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
	}
}

// ServeWebSocket serves tcp proxy over websocket.
func (p *TCPProxy) ServeWebSocket(w http.ResponseWriter, req *http.Request, target *url.URL) {
	err := p.proxy(w, req, target)
	if err != nil {
		// see: NewReverseProxy
		select {
		case <-req.Context().Done():
			w.WriteHeader(httpStatusClientClosedRequest)
			return
		default:
		}

		if errors.Is(err, ErrBadRequest) {
			p.logger.Error(err, "invalid request")
			w.WriteHeader(http.StatusBadRequest)
			return
		}
		p.logger.Error(err, "unexpected error")
		w.WriteHeader(http.StatusBadGateway)
		return
	}
}

// Basically, connection is coming from the API is forwarded as is.
// Even if tls is enabled, forwarding the connection information as it is will eventually achieve
// the "client (tls enabled) <--> tenant server (tls enabled)" state.
//
// Consider here of the sql driver
//
// 1. enabled tls sql driver
//   - "sql driver (api)" <- [tls over tcp] -> "tcp proxy (api)" <- [tls over HTTP] -> "bridge" <- [tls over tcp] -> DB
// 2. enabled tls sql driver and bridge
//   - "sql driver (api)" <- [tls over tcp] -> "tcp proxy (api)" <- [tls over HTTPS] -> "bridge" <- [tls over tcp] -> DB
func (p *TCPProxy) proxy(w http.ResponseWriter, req *http.Request, target *url.URL) error {
	if err := validateAndGetTarget(req, target); err != nil {
		return err
	}

	hijacker, ok := w.(http.Hijacker)
	if !ok {
		return errors.New("unexpected response writer")
	}

	conn, err := p.dialContextFunc(req.Context(), "tcp", target.Host)
	if err != nil {
		return fmt.Errorf("failed to dial to host %q: %w", target.Host, err)
	}
	defer conn.Close()

	// start forwards tcp connection over HTTP
	//
	// We have to treat the HTTP connection as websocket to do bi-directional stream
	// on any serverless functions
	w.Header().Set("Upgrade", "websocket")
	w.Header().Set("Connection", "Upgrade")
	nonce := req.Header.Get(secWebSocketKey)
	w.Header().Set(secWebSocketAcceptKey, getNonceAccept(nonce))
	w.WriteHeader(http.StatusSwitchingProtocols)

	hijackedConn, brw, err := hijacker.Hijack()
	if err != nil {
		return fmt.Errorf("failed to hijack connection: %w", err)
	}
	defer hijackedConn.Close()

	hijackedConn = &bufConn{
		rawConn: hijackedConn,
		reader:  brw.Reader,
	}

	// From this point on, it is a tcp proxy world.
	// We should not handle HTTP's context.Context and
	// should not do for any other http-related operations.
	return tcpPipe(conn, hijackedConn)
}

func validateAndGetTarget(req *http.Request, target *url.URL) error {
	if req.Method != http.MethodGet {
		return fmt.Errorf("connect only: %w", ErrBadRequest)
	}
	if req.Header.Get(secWebSocketKey) == "" {
		return fmt.Errorf("challenge is failed: %w", ErrBadRequest)
	}
	if target.Scheme != TCPScheme {
		return fmt.Errorf("unexpected schema %q: %w", target.Scheme, ErrBadRequest)
	}
	return nil
}

const (
	secWebSocketKey       = "Sec-Websocket-Key"
	secWebSocketAcceptKey = "Sec-WebSocket-Accept"
)

// getNonceAccept computes the base64-encoded SHA-1 of the concatenation of
// the nonce ("Sec-WebSocket-Key" value) with the websocket GUID string.
func getNonceAccept(nonce string) string {
	// generated by `$ uuidgen | pbcopy`
	const bridgeProxyGUID = "7F3BF345-7EBE-4A47-B868-12C3C486EB55"

	buf := bytes.NewBufferString(nonce)
	buf.WriteString(bridgeProxyGUID)
	sha := sha1.New().Sum(buf.Bytes())
	return base64.StdEncoding.EncodeToString(sha)
}

// generateNonce generates a nonce consisting of a randomly selected 16-byte
// value that has been base64-encoded.
//
// https://github.com/golang/net/blob/04defd469f4e290175cd2fb95a0e5f235f9bf173/websocket/hybi.go#L360-L370
func generateNonce() (nonce string) {
	return rand.String()
}
